# -*- coding: utf-8 -*-
"""Plakhotnik_HW2_3_python_basics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hzv08GfjVdHnrPouA5iXHS1xiZgf8Hak

# Python Bootcamp: Assignment 3 [100 points]

This week we will start writing some code! This assignment is designed to be a crash-course to get you up to speed on the level of Python you will need to know in order to do the remainder of the assignments. It's easiest to learn by doing, so please start early so we can help you get on board. You want to spend the semester focusing on the crowdsourcing and machine learning, not the indenting and semicoloning.

Before you do anything save a copy of this file in Drive (found in File) and work on that one.

## 1. Working with Lists [15 points]

1. **[5 points]** Consider the function `extract_and_apply(l, p, f)` shown below, which extracts the elements of a list `l` satisfying a boolean predicate `p`, applies a function f to each such element, and returns the result.

  Rewrite `extract_and_apply(l, p, f)` in one line using a list comprehension.
"""

def extract_and_apply(l, p, f):
     result = []
     for x in l:
         if p(x):
             result.append(f(x))
     return result

def extract_and_apply(l, p, f):
    return [f(x) for x in l if p(x)]

# # Example:
l = [1, 2, 3, 4]
p = lambda x: x % 2 == 0
f = lambda x: x
extract_and_apply(l, p, f)

# # Expected output:
# # [2, 4]

"""2. **[5 points]** Write a function `concatenate(seqs)` that returns a list containing the concatenation of the elements of the input sequences. Your implementation should consist of a single list comprehension, and should not exceed one line.


"""

def concatenate(seqs):
    return [x for i in seqs for x in i]

# # Example:
concatenate([[1, 2], [3, 4]])

# # Expected output:
# # [1, 2, 3, 4]

# # Example:
concatenate(["abc", (0, [0])])

# # Expected output:
# # ['a', 'b', 'c', 0, [0]]

"""3. **[5 points]** Write a function `transpose(matrix)` that returns the transpose of the input matrix, which is represented as a list of lists. Recall that the transpose of a matrix is obtained by swapping its rows with its columns. More concretely, the equality `matrix[i][j] == transpose(matrix)[j][i`] should hold for all valid indices `i` and `j`. You may assume that the input matrix is well-formed, i.e., that each row is of equal length. You may further assume that the input matrix is non-empty. Your function should not modify the input."""

def transpose(matrix):
    return [[matrix[i][j] for i in range(len(matrix))] for j in range(len(matrix[0]))]

# # Example:
transpose([[1, 2, 3]])

# # Expected output:
# # [[1], [2], [3]]

# # Example:
transpose([[1, 2], [3, 4], [5, 6]])

# # Expected output:
# # [[1, 3, 5], [2, 4, 6]]

"""## 2. Sequence Slicing [9 points]

The functions in this section should be implemented using sequence slices. Recall that the slice parameters take on sensible default values when omitted. In some cases, it may be necessary to use the optional third parameter to specify a step size.

1. **[3 points]** Write a function `copy(seq)` that returns a new sequence containing the same elements as the input sequence.
"""

def copy(seq):
    return seq[:]

# # Example:
copy("abc")

# # Expected output:
# # 'abc'

# # Example:
copy((1, 2, 3))

# # Expected output:
# #  (1, 2, 3)

# # Example:
x = [0, 0, 0]
y = copy(x)
print(x, y)

x[0] = 1
print(x, y)

# # Expected output:
# # [0, 0, 0] [0, 0, 0]
# # [1, 0, 0] [0, 0, 0]

"""2. **[3 points]** Write a function `all_but_last(seq)` that returns a new sequence containing all but the last element of the input sequence. If the input sequence is empty, a new empty sequence of the same type should be returned."""

def all_but_last(seq):
    return seq[:-1]

# # Example:
all_but_last("abc")

# # Expected output:
# # 'ab'

# # Example:
all_but_last((1, 2, 3))

# # Expected output:
# # (1, 2)

# # Example:
all_but_last("")

# # Expected output:
# # ''

# # Example:
all_but_last([])

# # Expected output:
# # []

"""3. **[3 points]** Write a function `every_other(seq)` that returns a new sequence containing every other element of the input sequence, starting with the first. This function can be written in one line using the optional third parameter of the slice notation."""

def every_other(seq):
  return seq[::2]

# # Example:
every_other([1, 2, 3, 4, 5])

# # Expected output:
# # [1, 3, 5]

# # Example:
every_other("abcde")

# # Expected output:
# # 'ace'

# # Example:
every_other([1, 2, 3, 4, 5, 6])

# # Expected output:
# # [1, 3, 5]

# # Example:
every_other("abcdef")

# # Expected output:
# # 'ace'

"""## 3. Combinatorial Algorithms [12 points]

The functions in this section should be implemented as generators. You may generate the output in any order you find convenient, as long as the correct elements are produced. However, in some cases, you may find that the order of the example output hints at a possible implementation.

Although generators in Python can be used in a variety of ways, you will not need to use any of their more sophisticated features here. Simply keep in mind that where you might normally return a list of elements, you should instead yield the individual elements.

Since the contents of a generator cannot be viewed without employing some form of iteration, we wrap all function calls in this section’s examples with the list function for convenience.

1. **[6 points]** The prefixes of a sequence include the empty sequence, the first element, the first two elements, etc., up to and including the full sequence itself. Similarly, the suffixes of a sequence include the empty sequence, the last element, the last two elements, etc., up to and including the full sequence itself. Write a pair of functions `prefixes(seq)` and `suffixes(seq)` that yield all prefixes and suffixes of the input sequence.
"""

def prefixes(seq):
    for i in range(len(seq) + 1):
        yield seq[:i]

def suffixes(seq):
    for i in range(len(seq) + 1):
        yield seq[i:]

# # Example:
list(prefixes([1, 2, 3]))

# # Expected output:
# # [[], [1], [1, 2], [1, 2, 3]]

# # Example:
list(suffixes([1, 2, 3]))

# # Expected output:
# # [[1, 2, 3], [2, 3], [3], []]

# # Example:
list(prefixes("abc"))

# # Expected output:
# # ['', 'a', 'ab', 'abc']

# # Example:
list(suffixes("abc"))

# # Expected output:
# # ['abc', 'bc', 'c', '']

"""2. **[6 points]** Write a function `slices(seq)` that yields all non-empty slices of the input sequence."""

def slices(seq):
    for i in range(len(seq)):
        for j in range(i + 1, len(seq) + 1):
            yield seq[i:j]

# # Example:
list(slices([1, 2, 3]))

# # Expected output:
# # [[1], [1, 2], [1, 2, 3], [2], [2, 3], [3]]

# # Example:
list(slices("abc"))

# # Expected output:
# # ['a', 'ab', 'abc', 'b', 'bc', 'c']

"""## 4. Text Processing [20 points]

1. **[5 points]** A common preprocessing step in many natural language processing tasks is text normalization, wherein words are converted to lowercase, extraneous whitespace is removed, etc. Write a function `normalize(text)` that returns a normalized version of the input string, in which all words have been converted to lowercase and are separated by a single space. No leading or trailing whitespace should be present in the output.
"""

def normalize(text):
    return " ".join(text.split()).lower()

# # Example:
normalize("This is an example.")

# # Expected output:
# # 'this is an example.'

# # Example:
normalize("   EXTRA   SPACE   ")

# # Expected output:
# # 'extra space'

"""2. **[5 points]** Write a function `no_vowels(text)` that removes all vowels from the input string and returns the result. For the purposes of this problem, the letter ‘y’ is not considered to be a vowel.


"""

def no_vowels(text):
    vowels = "aeuioAEUIO"
    return "".join([char for char in text if char not in vowels])

# # Example:
no_vowels("This Is An Example.")

# # Expected output:
# # 'Ths s n xmpl.'

# # Example:
no_vowels("We love Python!")

# # Expected output:
# # 'W lv Pythn!'

"""3. **[5 points]** Write a function `digits_to_words(text)` that extracts all digits from the input string, spells them out as lowercase English words, and returns a new string in which they are each separated by a single space. If the input string contains no digits, then an empty string should be returned."""

def digits_to_words(text):
    digits = {
        '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
        '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'
    }
    return " ".join([digits[char] for char in text if char.isdigit()])

# Example:
digits_to_words("Zip Code: 19104")

# Expected output:
# 'one nine one zero four'

# Example:
digits_to_words("Pi is 3.1415...")

# Expected output:
# 'three one four one five'

"""4. **[5 points]** Although there exist many naming conventions in computer programming, two of them are particularly widespread. In the first, words in a variable name are separated using underscores. In the second, words in a variable name are written in mixed case, and are strung together without a delimiter. By mixed case, we mean that the first word is written in lowercase, and that subsequent words have a capital first letter. Write a function `to_mixed_case(name)` that converts a variable `name` from the former convention to the latter. Leading and trailing underscores should be ignored. If the variable name consists solely of underscores, then an empty string should be returned.


"""

def to_mixed_case(name):
    parts = [part for part in name.split('_') if part]
    if not parts:
        return ''

    mixed_case_parts = [parts[0].lower()]
    for part in parts[1:]:
        mixed_case_parts.append(part.capitalize())

    return "".join(mixed_case_parts)

# Example:
to_mixed_case("to_mixed_case")

# Expected output:
# 'toMixedCase'

# Example:
to_mixed_case("__EXAMPLE__NAME__")

# Expected output:
# 'exampleName'

"""## 5. DataFrames [44 points]
In this section you'll get a feel for pandas' DataFrames a datastructure similar to SQL tables that can directly read lists and csvs and supports a number of optimized operations.

### 5.1 Manipulating a csv [30 points]
"""

# first we'll import pandas
import pandas as pd

"""1. **[2 points]** In the method `read_file` create a dataframe from the given csv file."""

# hint: look at the pandas method read_csv
def read_file(file):
    """
    Returns
    -------
    Dataframe created from the given file
    """
    return pd.read_csv(file)

df = read_file('batch.csv')

"""batch.csv is a csv of the results from a batch of HITs on MTurk. With it you can see worker Ids, their answers to each question, as well as their accept and submit times.

Comment the cells below out before you submit.
"""

# you can also get a smaller glimpse with
# display (df.head())

# or just the columns with
# display (df.columns)

# a slice of a dataframe is called a series. for example:
# display (df['HITId'])

"""2. **[3 points]** Write the method `get_workerId_by_row` that returns the Worker ID at the given row in the dataframe."""

def get_workerId_by_row(df, row):
    return df.loc[row, 'WorkerId']

# EXAMPLE
get_workerId_by_row(df, 3)
# 'A98E8M4QLI9RS'

"""3. **[5 points]** In the method `format_date` convert a datetime string from the format Year-Month-Day Hour-Minute-Second to a timestamp in minutes."""

from datetime import datetime
# TODO
# convert the given date into a timestamp (in seconds)
def format_date(date):
    dt_date = datetime.strptime(date, '%Y-%m-%d %H:%M:%S')
    return dt_date.timestamp() / 60

# EXAMPLE
format_date('2020-02-06 23:25:41') # -> 26350525.683333334

"""4. **[5 points]** Use the `format_date` method to convert each entry in `SubmitTime` and `AcceptTime` into a timestamp. In `convert_times` return the series you get by applying that method to each entry in the given column"""

# hint: look at the dataframe apply method
def convert_times(df, column):
    return df[column].apply(format_date)

# comment these out before you submit
# df['SubmitTime'] = convert_times(df, 'SubmitTime')
# df['AcceptTime'] = convert_times(df, 'AcceptTime')

"""5. **[5 points]** In `get_work_time` figure out how long each worker spent on the batch. Return the series that is the total work time indexed by the worker id."""

# hint: look at the dataframe groupby function
def get_work_time(df):
    work_time_series = df['SubmitTime'] - df['AcceptTime']
    df['WorkTime'] = work_time_series
    return df.groupby('WorkerId')['WorkTime'].sum()

# work_time_by_worker = get_work_time(df)
# print(work_time_by_worker)

# EXAMPLE
# Should be a series like
# Time
# Time

"""6. **[10 points]** As we talked about in class workers can use tools to accept batches of HITs at once and then work on them sequentially. We suspect some of the workers in this batch have been using such a tool and that their work times overestimate how long they actually spent working. Write a method to calculate how long each worker actually spent working.

Hint: try to think about a worker's accept and submit times would look like if they were doing this and any overlap you might be able to find.
"""

def calculated_work_time(df):
    df_sorted = df.sort_values(by=['WorkerId', 'AcceptTime']).copy()
    worker_times = {}

    for worker_id, group in df_sorted.groupby('WorkerId'):
        group['AcceptTime'] = pd.to_datetime(group['AcceptTime'])
        group['SubmitTime'] = pd.to_datetime(group['SubmitTime'])

        total_time = pd.Timedelta(0)
        current_start = group['AcceptTime'].iloc[0]
        current_end = group['SubmitTime'].iloc[0]
        
        for i in range(1, len(group)):
            next_start = group['AcceptTime'].iloc[i]
            next_end = group['SubmitTime'].iloc[i]

            if next_start <= current_end:
                current_end = max(current_end, next_end)
            else:
                total_time += (current_end - current_start)
                current_start = next_start
                current_end = next_end
        
        total_time += (current_end - current_start)
        worker_times[worker_id] = total_time

    return pd.Series(worker_times)

# actual_work_time = calculated_work_time(df)
# print(actual_work_time)

# EXAMPLE
# Series should look the same as above but with different values for some workers

"""7. **[0 points]** Here we'll show you how you can plot the data you just looked at.

Comment all of this out before you submit.
"""

# plot_df = pd.DataFrame()

# plot_df['WorkTime'] = get_work_time(df)

# plot_df['CWorkTime'] = calculated_work_time(df)

# plot_df.plot(kind='bar')

"""### 5.2 A Simple Program to Read from the Web [14 points]

The cell below uses the Pandas library to read a table from the given web page (the Wikipedia information on films in the year 2010). The code loads this into a list of DataFrames called films_2010. We then pull the table at index 3, then do some simple data wrangling on top_films to set up the appropriate types.

Run the cells below.
"""

# CAUTION: comment this out before you submit!
# !pip install money-parser

import pandas as pd
from money_parser import price_dec

"""**TODO:** Read in a list of dataframes from the url https://en.wikipedia.org/wiki/2010_in_film

*Hint:* Check the pandas documentation
"""

import requests
from io import StringIO

def read_from_html(url):
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                             "AppleWebKit/537.36 (KHTML, like Gecko) "
                             "Chrome/120.0.0.0 Safari/537.36"
                             "Chrome/91.0.4472.124 Safari/537.36"
                             "Chrome/91.0.4472.124 Safari/537.36"}
    response = requests.get(url, headers=headers)
    response.raise_for_status()

    return pd.read_html(StringIO(response.text))

films_2010 = read_from_html('https://en.wikipedia.org/wiki/2010_in_film')

# print(f"Number of tables: {len(films_2010)}")
# print(films_2010[0].head())

"""**TODO:** Find the table titled "Highest-grossing films"

*Hint:* Click on the url, and do some digging! Check out "Developer Tools" for the underlying html code and check which  < table >  tag contains the desired data
"""

def get_film_data(df_list):
    for df in df_list:
        if 'Rank' in df.columns and 'Title' in df.columns:
            return df
    raise ValueError("Highest-grossing films' table not found!")

top_films = get_film_data(films_2010)

# print(top_films.head())

"""**TODO:** write a method that sets the 'Rank' column as the index"""

def set_index(df, column):
    return df.set_index(column)

top_films_ranked = set_index(top_films, 'Rank')

# print(top_films_ranked.head())

"""**TODO:** write a function that creates a column named 'Revenue (millions)', where the revenue in millions (rounded to 2 decimal places) are to be stored.

*Hint:* We recommend you use the imported function from the 'money_parser' module (see above).
"""

import re
from money_parser import price_str

def extract_revenue(df, column, name):
    def clean_and_parse(text):
        if pd.isna(text):
            return None
        clean_text = re.sub(r"\[.*?\]|\(.*?\)", "", str(text)).strip()
        try:
            return round(float(price_str(clean_text)) / 1_000_000, 2)
        except Exception:
            numbers = re.findall(r'[\d,]+\.?\d*', clean_text)
            if numbers:
                return round(float(numbers[0].replace(',', '')) / 1_000_000, 2)
            return None

    df[name] = df[column].apply(clean_and_parse)
    return df

top_films_revenue = extract_revenue(top_films_ranked, 'Worldwide gross', 'Revenue (millions)')

# print(top_films_revenue[['Title', 'Worldwide gross', 'Revenue (millions)']].head())

"""Can we programmatically compute how many entries were scored as top films?

You can use the Python shape function on a dataframe to determine the dimensions!
To learn more about the shape function, you can search for its pandas documentation.

**TODO:** Create a function that calculates the shape of the final dataframe (top_films_revenue) and returns a tuple
"""

def get_dimensions(df):
    return df.shape

# print(get_dimensions(top_films_revenue))
